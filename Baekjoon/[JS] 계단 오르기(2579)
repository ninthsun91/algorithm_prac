/**
 * 
 * 한계단 혹은 두계단
 * 연속된 세개의 계단 밟으면 안됨
 * 마지막 계단은 반드시 밟아야함
 * 
 * 얻을 수 있는 최대값
 * 
 * Stair
 * Sum
 * 
 * Sum[n] = Stair[n] + Max( Sum[n-1], Sum[n-2])
 * 
 * 연속된 세개 금지는 어떻게?
 * n-1 > n-2
 * n-2 > max( n-1, n-2 )
 * 
 */

// const rl = require('readline').createInterface({
//     input: process.stdin,
//     output: process.stdout
// });

// const stair = [];

// rl.on('line', (line)=>{
//     stair.push(Number(line));

//     if (stair.length-1 === stair[0]) rl.close();
// });

// rl.on('close', () => {
//     const N = stair.shift();
//     stair.unshift(0);
//     const sum = new Array(N+1);
//     sum[0] = 0
//     sum[1] = stair[1];

//     let step = 0;
//     for (let n=2; n<N+1; n++) {
//         if (step === 1) {
//             sum[n] = stair[n] + sum[n-2];
//             step = 2;
//             continue;
//         }

//         if (sum[n-1] >= sum[n-2]) {
//             sum[n] = stair[n] + sum[n-1];
//             step = 1;
//         } else {
//             sum[n] = stair[n] + sum[n-2];
//             step = 2;
//         }
//     }

//     console.log(sum[N]);
// });


/**
 * 
 * 오답!
 * 반례?
 * 
 * 예제의 3번째 칸에서 벌써 틀렸다.
 * 내 식은, sum = [0, 10, 30, 25]가 되며,
 * n 이 3일 때 앞서서 sum[2]가 30이 되기 위해 한칸만 건넜으므로 sum[3]은 sum[1]을 사용할 수 밖에 없다.
 * 하지만 실제로는 sum[2]가 최대값이 아니었던 20에서 넘어오는게 더 크다.
 * 
 * 그럼 차라리 가능한 모든 sum[n]의 합을 Set에 담는다면?
 * 
 * 어차피 
 * 
 */

 const rl = require('readline').createInterface({
    input: process.stdin,
    output: process.stdout
});

const stair = [];

rl.on('line', (line)=>{
    stair.push(Number(line));

    if (stair.length-1 === stair[0]) rl.close();
});

rl.on('close', () => {
    const N = stair.shift();
    stair.unshift(0);
    const sum = Array.from({length: N+1}, ()=>[0])
});
